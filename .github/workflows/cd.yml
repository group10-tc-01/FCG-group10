name: Pipeline CD Simplificado

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Tipo de release'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major

permissions:
  contents: write
  packages: write

env:
  REGISTRY: ${{ secrets.AZURE_CONTAINER_REGISTRY_NAME }}.azurecr.io

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout do código
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Preparar variáveis e encontrar Dockerfile
      id: vars
      run: |
        # Converter APP_NAME para lowercase para Docker
        image_name_lower=$(echo "${{ secrets.APP_NAME }}" | tr '[:upper:]' '[:lower:]')
        echo "image_name_lower=$image_name_lower" >> $GITHUB_OUTPUT
        echo "📦 Nome da imagem Docker: $image_name_lower"
        
        # Procurar Dockerfile em locais comuns
        dockerfile_path=""
        
        if [ -f "Dockerfile" ]; then
          dockerfile_path="."
          dockerfile_file="Dockerfile"
          echo "✅ Dockerfile encontrado na raiz!"
        elif [ -f "src/FCG.WebApi/Dockerfile" ]; then
          dockerfile_path="src/FCG.WebApi"
          dockerfile_file="Dockerfile"
          echo "✅ Dockerfile encontrado em: src/FCG.WebApi/"
        else
          echo "❌ Dockerfile não encontrado!"
          echo "📁 Estrutura do repositório:"
          find . -name "Dockerfile" -o -name "*.csproj" | head -10
          exit 1
        fi
        
        echo "dockerfile_path=$dockerfile_path" >> $GITHUB_OUTPUT
        echo "dockerfile_file=$dockerfile_file" >> $GITHUB_OUTPUT
        echo "📄 Usando Dockerfile em: $dockerfile_path/$dockerfile_file"
    
    - name: Gerar versão
      id: version
      run: |
        # Obter última tag
        latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "Última tag: $latest_tag"
        
        # Remover 'v' prefix
        version_without_v=${latest_tag#v}
        
        # Parse da versão semântica
        IFS='.' read -r major minor patch <<< "$version_without_v"
        
        # Determinar tipo de incremento
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          release_type="${{ github.event.inputs.release_type }}"
        else
          release_type="patch"
        fi
        
        # Incrementar versão
        case $release_type in
          "major")
            major=$((major + 1))
            minor=0
            patch=0
            ;;
          "minor")
            minor=$((minor + 1))
            patch=0
            ;;
          "patch")
            patch=$((patch + 1))
            ;;
        esac
        
        new_version="$major.$minor.$patch"
        tag="v$new_version"
        
        echo "Nova versão: $new_version"
        echo "Nova tag: $tag"
        
        echo "version=$new_version" >> $GITHUB_OUTPUT
        echo "tag=$tag" >> $GITHUB_OUTPUT
    
    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Login no Azure Container Registry
      uses: azure/docker-login@v1
      with:
        login-server: ${{ env.REGISTRY }}
        username: ${{ secrets.AZURE_CONTAINER_REGISTRY_USERNAME }}
        password: ${{ secrets.AZURE_CONTAINER_REGISTRY_PASSWORD }}
    
    - name: Build e push da imagem Docker
      run: |
        # Usar nome em lowercase para Docker
        IMAGE_LOWER="${{ env.REGISTRY }}/${{ steps.vars.outputs.image_name_lower }}"
        DOCKERFILE_PATH="${{ steps.vars.outputs.dockerfile_path }}"
        DOCKERFILE_FILE="${{ steps.vars.outputs.dockerfile_file }}"
        
        echo "🔨 Fazendo build da imagem: ${IMAGE_LOWER}:${{ steps.version.outputs.version }}"
        echo "📄 Usando Dockerfile: $DOCKERFILE_PATH/$DOCKERFILE_FILE"
        echo "📁 Context: ."
        echo ""
        echo "--- Primeiras linhas do Dockerfile ---"
        head -10 "$DOCKERFILE_PATH/$DOCKERFILE_FILE"
        echo "---"
        
        # Build com o Dockerfile correto
        # O context sempre será a raiz (.) para que os COPY funcionem corretamente
        docker build \
          --file "$DOCKERFILE_PATH/$DOCKERFILE_FILE" \
          --build-arg BUILD_CONFIGURATION=Release \
          -t ${IMAGE_LOWER}:${{ steps.version.outputs.version }} \
          -t ${IMAGE_LOWER}:latest \
          .
        
        echo "📤 Fazendo push das imagens..."
        docker push ${IMAGE_LOWER}:${{ steps.version.outputs.version }}
        docker push ${IMAGE_LOWER}:latest
        
        # Salvar nome da imagem para usar no deploy
        echo "full_image_name=${IMAGE_LOWER}:${{ steps.version.outputs.version }}" >> $GITHUB_OUTPUT
      id: docker
    
    - name: Deploy no Azure Web App
      uses: azure/webapps-deploy@v2
      with:
        app-name: ${{ secrets.AZURE_WEBAPP_NAME }}
        publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
        images: ${{ steps.docker.outputs.full_image_name }}
    
    - name: Aguardar deploy e testar
      run: |
        echo "⏳ Aguardando deploy..."
        sleep 90
        
        app_url="https://${{ secrets.AZURE_WEBAPP_NAME }}.azurewebsites.net"
        
        # Teste básico de saúde
        echo "🔍 Testando aplicação..."
        for i in {1..30}; do
          echo "Tentativa $i/30..."
          
          response=$(curl -s -o /dev/null -w "%{http_code}" "$app_url" || echo "000")
          if [ "$response" = "200" ] || [ "$response" = "404" ] || [ "$response" = "403" ]; then
            echo "✅ Aplicação está respondendo! Status: $response"
            break
          fi
          
          if [ $i -eq 30 ]; then
            echo "❌ Aplicação não respondeu após 5 minutos"
            exit 1
          fi
          
          sleep 10
        done
    
    - name: Criar release
      run: |
        # Criar tag
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag -a ${{ steps.version.outputs.tag }} -m "Release ${{ steps.version.outputs.version }}"
        git push origin ${{ steps.version.outputs.tag }}
        
        # Gerar changelog
        echo "## 🚀 Release ${{ steps.version.outputs.version }}" > changelog.md
        echo "" >> changelog.md
        
        # Adicionar tipo de trigger
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "📋 **Tipo**: Release Manual (${{ github.event.inputs.release_type }})" >> changelog.md
        else
          echo "📋 **Tipo**: Release Automático (patch)" >> changelog.md
        fi
        
        echo "" >> changelog.md
        echo "## 📋 Informações Técnicas" >> changelog.md
        echo "- **Versão**: ${{ steps.version.outputs.version }}" >> changelog.md
        echo "- **Commit**: ${{ github.sha }}" >> changelog.md
        echo "- **Imagem Docker**: ${{ steps.docker.outputs.full_image_name }}" >> changelog.md
        echo "- **Deploy**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> changelog.md
        
        # Adicionar commits desde última tag (se houver)
        latest_tag=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
        if [ -n "$latest_tag" ] && [ "$latest_tag" != "${{ steps.version.outputs.tag }}" ]; then
          echo "" >> changelog.md
          echo "## 📝 Mudanças" >> changelog.md
          git log $latest_tag..HEAD --pretty=format:"- %s" --no-merges >> changelog.md
        fi
    
    - name: Criar GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.version.outputs.tag }}
        name: "Release ${{ steps.version.outputs.version }}"
        body_path: changelog.md
        draft: false
        generate_release_notes: true